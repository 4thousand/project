{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/@ionic-native/plugins/code-push/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAC3C,OAAO,EAAE,OAAO,EAAE,iBAAiB,EAAE,MAAM,EAAE,MAAM,oBAAoB,CAAC;AACxE,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAwR7C;;GAEG;;;;AACH,MAAM,CAAN,IAAY,UA+CX;;;;AA/CD,WAAY,UAAU;IACpB;;OAEG;IACH,uDAAU,CAAA;IAEV;;;OAGG;IACH,mEAAgB,CAAA;IAEhB;;OAEG;IACH,+DAAc,CAAA;IAEd;;;OAGG;IACH,6CAAK,CAAA;IAEL;;OAEG;IACH,yDAAW,CAAA;IAEX;;OAEG;IACH,yEAAmB,CAAA;IAEnB;;OAEG;IACH,2EAAoB,CAAA;IAEpB;;OAEG;IACH,yEAAmB,CAAA;IAEnB;;OAEG;IACH,qEAAiB,CAAA;GA9CP,UAAU,KAAV,UAAU,QA+CrB;AAED;;GAEG;;;;AACH,MAAM,CAAN,IAAY,WAeX;;;;AAfD,WAAY,WAAW;IACrB;;OAEG;IACH,uDAAS,CAAA;IAET;;OAEG;IACH,mEAAe,CAAA;IAEf;;OAEG;IACH,iEAAc,CAAA;GAdJ,WAAW,KAAX,WAAW,QAetB;;;;;;;;;;;;;;;;;;;;;;;;;;IA2I6B,4BAAiB;;;;IAC7C;;;;OAIG;;;;;;IAEH,oCAAiB;;;;;;QACf,MAAM,CAAC;KACR;IAED;;;;OAIG;;;;;;IAEH,oCAAiB;;;;;;QACf,MAAM,CAAC;KACR;IAED;;;;;OAKG;;;;;;;IAIH,iCAAc;;;;;;cAAC,aAAsB;QACnC,MAAM,CAAC;KACR;IAED;;;;;;OAMG;;;;;;;;IAEH,yCAAsB;;;;;;;;QACpB,MAAM,CAAC;KACR;IAED;;;;OAIG;;;;;;IAEH,qCAAkB;;;;;;QAChB,MAAM,CAAC;KACR;IAED;;;;;;;;;;;;;;;;;;;OAmBG;;;;;;;;;;;;;;;;;;;;;IAMH,uBAAI;;;;;;;;;;;;;;;;;;;;cACF,WAAyB,EACzB,gBAAoD;QAEpD,MAAM,CAAC;KACR;;gBAvFF,UAAU;;;QAOR,OAAO,EAAE;;;;qDAGT;;QAOA,OAAO,EAAE;;;;qDAGT;;QAQA,OAAO,CAAC;YACP,aAAa,EAAE,SAAS;SACzB,CAAC;;;;kDAGD;;QASA,OAAO,EAAE;;;;0DAGT;;QAOA,OAAO,EAAE;;;;sDAGT;;QAsBA,OAAO,CAAC;YACP,UAAU,EAAE,IAAI;YAChB,YAAY,EAAE,CAAC;YACf,UAAU,EAAE,CAAC;SACd,CAAC;;;wCAIC,UAAU;wCAEZ;;;;;;;;;;;;;;;;;;;;;;;;;IAtFU,QAAQ;QARpB,MAAM,CAAC;YACN,UAAU,EAAE,UAAU;YACtB,MAAM,EAAE,0BAA0B;YAClC,SAAS,EAAE,UAAU;YACrB,IAAI,EAAE,uDAAuD;YAC7D,SAAS,EAAE,CAAC,SAAS,EAAE,KAAK,CAAC;SAC9B,CAAC;OAEW,QAAQ,EAuFpB;mBAlkBD;EA2e8B,iBAAiB;SAAlC,QAAQ","sourcesContent":["import { Injectable } from '@angular/core';\nimport { Cordova, IonicNativePlugin, Plugin } from '@ionic-native/core';\nimport { Observable } from 'rxjs/Observable';\n\nnamespace Http {\n  export const enum Verb {\n    GET,\n    HEAD,\n    POST,\n    PUT,\n    DELETE,\n    TRACE,\n    OPTIONS,\n    CONNECT,\n    PATCH\n  }\n\n  export interface Response {\n    statusCode: number;\n    body?: string;\n  }\n\n  export interface Requester {\n    request(verb: Verb, url: string, callback: Callback<Response>): void;\n    request(\n      verb: Verb,\n      url: string,\n      requestBody: string,\n      callback: Callback<Response>\n    ): void;\n  }\n}\n\n/**\n * Defines a package. All fields are non-nullable, except when retrieving the currently running package on the first run of the app,\n * in which case only the appVersion is compulsory.\n *\n * !! THIS TYPE IS READ FROM NATIVE CODE AS WELL. ANY CHANGES TO THIS INTERFACE NEEDS TO BE UPDATED IN NATIVE CODE !!\n */\nexport interface IPackage {\n  deploymentKey: string;\n  description: string;\n  label: string;\n  appVersion: string;\n  isMandatory: boolean;\n  packageHash: string;\n  packageSize: number;\n  failedInstall: boolean;\n}\n\n/**\n * Defines a remote package, which represents an update package available for download.\n */\nexport interface IRemotePackage extends IPackage {\n  /**\n   * The URL at which the package is available for download.\n   */\n  downloadUrl: string;\n\n  /**\n   * Downloads the package update from the CodePush service.\n   *\n   * @param {SuccessCallback} downloadSuccess Called with one parameter, the downloaded package information, once the download completed successfully.\n   * @param {ErrorCallback} [downloadError] Optional callback invoked in case of an error.\n   * @param {SuccessCallback<DownloadProgress>} [downloadProgress] Optional callback invoked during the download process. It is called several times with one DownloadProgress parameter.\n   */\n  download(\n    downloadSuccess: SuccessCallback<ILocalPackage>,\n    downloadError?: ErrorCallback,\n    downloadProgress?: SuccessCallback<DownloadProgress>\n  ): void;\n\n  /**\n   * Aborts the current download session, previously started with download().\n   *\n   * @param {SuccessCallback<void>} [abortSuccess] Optional callback invoked if the abort operation succeeded.\n   * @param {ErrorCallback} [abortError] Optional callback invoked in case of an error.\n   */\n  abortDownload(\n    abortSuccess?: SuccessCallback<void>,\n    abortError?: ErrorCallback\n  ): void;\n}\n\n/**\n * Defines a local package.\n *\n * !! THIS TYPE IS READ FROM NATIVE CODE AS WELL. ANY CHANGES TO THIS INTERFACE NEEDS TO BE UPDATED IN NATIVE CODE !!\n */\nexport interface ILocalPackage extends IPackage {\n  /**\n   * The local storage path where this package is located.\n   */\n  localPath: string;\n\n  /**\n   * Indicates if the current application run is the first one after the package was applied.\n   */\n  isFirstRun: boolean;\n\n  /**\n   * Applies this package to the application. The application will be reloaded with this package and on every application launch this package will be loaded.\n   * On the first run after the update, the application will wait for a codePush.notifyApplicationReady() call. Once this call is made, the install operation is considered a success.\n   * Otherwise, the install operation will be marked as failed, and the application is reverted to its previous version on the next run.\n   *\n   * @param {SuccessCallback<InstallMode>} installSuccess Callback invoked if the install operation succeeded.\n   * @param {ErrorCallback} [installError] Optional callback invoked in case of an error.\n   * @param {InstallOptions} [installOptions] Optional parameter used for customizing the installation behavior.\n   */\n  install(\n    installSuccess: SuccessCallback<InstallMode>,\n    errorCallback?: ErrorCallback,\n    installOptions?: InstallOptions\n  ): void;\n}\n\n/**\n * Decomposed static side of RemotePackage.\n * For Class Decomposition guidelines see http://www.typescriptlang.org/Handbook#writing-dts-files-guidelines-and-specifics\n */\n/* tslint:disable */\ninterface RemotePackage_Static {\n  new (): IRemotePackage;\n}\n/* tslint:enable */\n\n/**\n * Decomposed static side of LocalPackage.\n * For Class Decomposition guidelines see http://www.typescriptlang.org/Handbook#writing-dts-files-guidelines-and-specifics\n */\n/* tslint:disable */\ninterface LocalPackage_Static {\n  new (): ILocalPackage;\n}\n/* tslint:enable */\n\ndeclare const RemotePackage: RemotePackage_Static;\ndeclare const LocalPackage: LocalPackage_Static;\n\n/**\n * Defines the JSON format of the current package information file.\n * This file is stored in the local storage of the device and persists between store updates and code-push updates.\n *\n * !! THIS FILE IS READ FROM NATIVE CODE AS WELL. ANY CHANGES TO THIS INTERFACE NEEDS TO BE UPDATED IN NATIVE CODE !!\n */\ninterface IPackageInfoMetadata extends ILocalPackage {\n  nativeBuildTime: string;\n}\n\ninterface NativeUpdateNotification {\n  updateAppVersion: boolean; // Always true\n  appVersion: string;\n}\n\nexport interface Callback<T> {\n  (error: Error, parameter: T): void;\n}\nexport interface SuccessCallback<T> {\n  (result?: T): void;\n}\nexport interface ErrorCallback {\n  (error?: Error): void;\n}\n\ninterface Configuration {\n  appVersion: string;\n  clientUniqueId: string;\n  deploymentKey: string;\n  serverUrl: string;\n  ignoreAppVersion?: boolean;\n}\n\ndeclare class AcquisitionStatus {\n  static DeploymentSucceeded: string;\n  static DeploymentFailed: string;\n}\n\ndeclare class AcquisitionManager {\n  constructor(httpRequester: Http.Requester, configuration: Configuration);\n  public queryUpdateWithCurrentPackage(\n    currentPackage: IPackage,\n    callback?: Callback<IRemotePackage | NativeUpdateNotification>\n  ): void;\n  public reportStatusDeploy(\n    pkg?: IPackage,\n    status?: string,\n    previousLabelOrAppVersion?: string,\n    previousDeploymentKey?: string,\n    callback?: Callback<void>\n  ): void;\n  public reportStatusDownload(pkg: IPackage, callback?: Callback<void>): void;\n}\n\ninterface CodePushCordovaPlugin {\n  /**\n   * Get the current package information.\n   *\n   * @param packageSuccess Callback invoked with the currently deployed package information.\n   * @param packageError Optional callback invoked in case of an error.\n   */\n  getCurrentPackage(\n    packageSuccess: SuccessCallback<ILocalPackage>,\n    packageError?: ErrorCallback\n  ): void;\n\n  /**\n   * Gets the pending package information, if any. A pending package is one that has been installed but the application still runs the old code.\n   * This happens only after a package has been installed using ON_NEXT_RESTART or ON_NEXT_RESUME mode, but the application was not restarted/resumed yet.\n   */\n  getPendingPackage(\n    packageSuccess: SuccessCallback<ILocalPackage>,\n    packageError?: ErrorCallback\n  ): void;\n\n  /**\n   * Checks with the CodePush server if an update package is available for download.\n   *\n   * @param {SuccessCallback<IRemotePackage>} querySuccess Callback invoked in case of a successful response from the server.\n   *                     The callback takes one RemotePackage parameter. A non-null package is a valid update.\n   *                     A null package means the application is up to date for the current native application version.\n   * @param {ErrorCallback} [queryError] Optional callback invoked in case of an error.\n   * @param {string} [deploymentKey] Optional deployment key that overrides the config.xml setting.\n   */\n  checkForUpdate(\n    querySuccess: SuccessCallback<IRemotePackage>,\n    queryError?: ErrorCallback,\n    deploymentKey?: string\n  ): void;\n\n  /**\n   * Notifies the plugin that the update operation succeeded and that the application is ready.\n   * Calling this function is required on the first run after an update. On every subsequent application run, calling this function is a noop.\n   * If using sync API, calling this function is not required since sync calls it internally.\n   *\n   * @param {SuccessCallback<void>} [notifySucceeded] Optional callback invoked if the plugin was successfully notified.\n   * @param {ErrorCallback} [notifyFailed] Optional callback invoked in case of an error during notifying the plugin.\n   */\n  notifyApplicationReady(\n    notifySucceeded?: SuccessCallback<void>,\n    notifyFailed?: ErrorCallback\n  ): void;\n\n  /**\n   * Reloads the application. If there is a pending update package installed using ON_NEXT_RESTART or ON_NEXT_RESUME modes, the update\n   * will be immediately visible to the user. Otherwise, calling this function will simply reload the current version of the application.\n   *\n   * @param {SuccessCallback<void>} installSuccess\n   * @param {ErrorCallback} [errorCallback]\n   */\n  restartApplication(\n    installSuccess: SuccessCallback<void>,\n    errorCallback?: ErrorCallback\n  ): void;\n\n  /**\n   * Convenience method for installing updates in one method call.\n   * This method is provided for simplicity, and its behavior can be replicated by using window.codePush.checkForUpdate(), RemotePackage's download() and LocalPackage's install() methods.\n   *\n   * The algorithm of this method is the following:\n   * - Checks for an update on the CodePush server.\n   * - If an update is available\n   *         - If the update is mandatory and the alertMessage is set in options, the user will be informed that the application will be updated to the latest version.\n   *           The update package will then be downloaded and applied.\n   *         - If the update is not mandatory and the confirmMessage is set in options, the user will be asked if they want to update to the latest version.\n   *           If they decline, the syncCallback will be invoked with SyncStatus.UPDATE_IGNORED.\n   *         - Otherwise, the update package will be downloaded and applied with no user interaction.\n   * - If no update is available on the server, or if a previously rolled back update is available and the ignoreFailedUpdates is set to true, the syncCallback will be invoked with the SyncStatus.UP_TO_DATE.\n   * - If an error occurs during checking for update, downloading or installing it, the syncCallback will be invoked with the SyncStatus.ERROR.\n   *\n   * @param {SuccessCallback<SyncStatus>} [syncCallback] Optional callback to be called with the status of the sync operation.\n   *                     The callback will be called only once, and the possible statuses are defined by the SyncStatus enum.\n   * @param {SyncOptions} [syncOptions] Optional SyncOptions parameter configuring the behavior of the sync operation.\n   * @param {SuccessCallback<DownloadProgress>} [downloadProgress] Optional callback invoked during the download process. It is called several times with one DownloadProgress parameter.\n   *\n   */\n  sync(\n    syncCallback?: SuccessCallback<SyncStatus>,\n    syncOptions?: SyncOptions,\n    downloadProgress?: SuccessCallback<DownloadProgress>\n  ): void;\n}\n\n/**\n * Defines the possible result statuses of the window.codePush.sync operation.\n */\nexport enum SyncStatus {\n  /**\n   * The application is up to date.\n   */\n  UP_TO_DATE,\n\n  /**\n   * An update is available, it has been downloaded, unzipped and copied to the deployment folder.\n   * After the completion of the callback invoked with SyncStatus.UPDATE_INSTALLED, the application will be reloaded with the updated code and resources.\n   */\n  UPDATE_INSTALLED,\n\n  /**\n   * An optional update is available, but the user declined to install it. The update was not downloaded.\n   */\n  UPDATE_IGNORED,\n\n  /**\n   * An error happened during the sync operation. This might be an error while communicating with the server, downloading or unziping the update.\n   * The console logs should contain more information about what happened. No update has been applied in this case.\n   */\n  ERROR,\n\n  /**\n   * There is an ongoing sync in progress, so this attempt to sync has been aborted.\n   */\n  IN_PROGRESS,\n\n  /**\n   * Intermediate status - the plugin is about to check for updates.\n   */\n  CHECKING_FOR_UPDATE,\n\n  /**\n   * Intermediate status - a user dialog is about to be displayed. This status will be reported only if user interaction is enabled.\n   */\n  AWAITING_USER_ACTION,\n\n  /**\n   * Intermediate status - the update package is about to be downloaded.\n   */\n  DOWNLOADING_PACKAGE,\n\n  /**\n   * Intermediate status - the update package is about to be installed.\n   */\n  INSTALLING_UPDATE\n}\n\n/**\n * Defines the available install modes for updates.\n */\nexport enum InstallMode {\n  /**\n   * The update will be applied to the running application immediately. The application will be reloaded with the new content immediately.\n   */\n  IMMEDIATE,\n\n  /**\n   * The update is downloaded but not installed immediately. The new content will be available the next time the application is started.\n   */\n  ON_NEXT_RESTART,\n\n  /**\n   * The udpate is downloaded but not installed immediately. The new content will be available the next time the application is resumed or restarted, whichever event happends first.\n   */\n  ON_NEXT_RESUME\n}\n\n/**\n * Defines the install operation options.\n */\nexport interface InstallOptions {\n  /**\n   * Used to specify the InstallMode used for the install operation. This is optional and defaults to InstallMode.ON_NEXT_RESTART.\n   */\n  installMode?: InstallMode;\n\n  /**\n   * If installMode === ON_NEXT_RESUME, the minimum amount of time (in seconds) which needs to pass with the app in the background before an update install occurs when the app is resumed.\n   */\n  minimumBackgroundDuration?: number;\n\n  /**\n   * Used to specify the InstallMode used for the install operation if the update is mandatory. This is optional and defaults to InstallMode.IMMEDIATE.\n   */\n  mandatoryInstallMode?: InstallMode;\n}\n\n/**\n * Defines the sync operation options.\n */\nexport interface SyncOptions extends InstallOptions {\n  /**\n   * Optional boolean flag. If set, previous updates which were rolled back will be ignored. Defaults to true.\n   */\n  ignoreFailedUpdates?: boolean;\n\n  /**\n   * Used to enable, disable or customize the user interaction during sync.\n   * If set to false, user interaction will be disabled. If set to true, the user will be alerted or asked to confirm new updates, based on whether the update is mandatory.\n   * To customize the user dialog, this option can be set to a custom UpdateDialogOptions instance.\n   */\n  updateDialog?: boolean | UpdateDialogOptions;\n\n  /**\n   * Overrides the config.xml deployment key when checking for updates.\n   */\n  deploymentKey?: string;\n}\n\n/**\n * Defines the configuration options for the alert or confirmation dialog\n */\nexport interface UpdateDialogOptions {\n  /**\n   * If a mandatory update is available and this option is set, the message will be displayed to the user in an alert dialog before downloading and installing the update.\n   * The user will not be able to cancel the operation, since the update is mandatory.\n   */\n  mandatoryUpdateMessage?: string;\n\n  /**\n   * If an optional update is available and this option is set, the message will be displayed to the user in a confirmation dialog.\n   * If the user confirms the update, it will be downloaded and installed. Otherwise, the update update is not downloaded.\n   */\n  optionalUpdateMessage?: string;\n\n  /**\n   * The title of the dialog box used for interacting with the user in case of a mandatory or optional update.\n   * This title will only be used if at least one of mandatoryUpdateMessage or optionalUpdateMessage options are set.\n   */\n  updateTitle?: string;\n\n  /**\n   * The label of the confirmation button in case of an optional update.\n   */\n  optionalInstallButtonLabel?: string;\n\n  /**\n   * The label of the cancel button in case of an optional update.\n   */\n  optionalIgnoreButtonLabel?: string;\n\n  /**\n   * The label of the continue button in case of a mandatory update.\n   */\n  mandatoryContinueButtonLabel?: string;\n\n  /**\n   * Flag indicating if the update description provided by the CodePush server should be displayed in the dialog box appended to the update message.\n   */\n  appendReleaseDescription?: boolean;\n\n  /**\n   * Optional prefix to add to the release description.\n   */\n  descriptionPrefix?: string;\n}\n\n/**\n * Defines the JSON format of the package diff manifest file.\n */\ninterface IDiffManifest {\n  deletedFiles: string[];\n}\n\n/**\n * Defines the format of the DownloadProgress object, used to send periodical update notifications on the progress of the update download.\n */\nexport interface DownloadProgress {\n  totalBytes: number;\n  receivedBytes: number;\n}\n\n/**\n * @name Code Push\n * @description\n * CodePush plugin for Cordova by Microsoft that supports iOS and Android.\n *\n * For more info, please see https://github.com/Dellos7/example-cordova-code-push-plugin\n *\n * @usage\n * ```typescript\n * import { CodePush } from '@ionic-native/code-push';\n *\n * constructor(private codePush: CodePush) { }\n *\n * ...\n *\n * // note - mostly error & completed methods of observable will not fire\n * // as syncStatus will contain the current state of the update\n * this.codePush.sync().subscribe((syncStatus) => console.log(syncStatus));\n *\n * const downloadProgress = (progress) => { console.log(`Downloaded ${progress.receivedBytes} of ${progress.totalBytes}`); }\n * this.codePush.sync({}, downloadProgress).subscribe((syncStatus) => console.log(syncStatus));\n *\n * ```\n */\n@Plugin({\n  pluginName: 'CodePush',\n  plugin: 'cordova-plugin-code-push',\n  pluginRef: 'codePush',\n  repo: 'https://github.com/Microsoft/cordova-plugin-code-push',\n  platforms: ['Android', 'iOS']\n})\n@Injectable()\nexport class CodePush extends IonicNativePlugin {\n  /**\n   * Get the current package information.\n   *\n   * @returns {Promise<ILocalPackage>}\n   */\n  @Cordova()\n  getCurrentPackage(): Promise<ILocalPackage> {\n    return;\n  }\n\n  /**\n   * Gets the pending package information, if any. A pending package is one that has been installed but the application still runs the old code.\n   * This happens only after a package has been installed using ON_NEXT_RESTART or ON_NEXT_RESUME mode, but the application was not restarted/resumed yet.\n   * @returns {Promise<ILocalPackage>}\n   */\n  @Cordova()\n  getPendingPackage(): Promise<ILocalPackage> {\n    return;\n  }\n\n  /**\n   * Checks with the CodePush server if an update package is available for download.\n   *\n   * @param {string} [deploymentKey] Optional deployment key that overrides the config.xml setting.\n   * @returns {Promise<IRemotePackage>}\n   */\n  @Cordova({\n    callbackOrder: 'reverse'\n  })\n  checkForUpdate(deploymentKey?: string): Promise<IRemotePackage> {\n    return;\n  }\n\n  /**\n   * Notifies the plugin that the update operation succeeded and that the application is ready.\n   * Calling this function is required on the first run after an update. On every subsequent application run, calling this function is a noop.\n   * If using sync API, calling this function is not required since sync calls it internally.\n   *\n   * @returns {Promise<void>}\n   */\n  @Cordova()\n  notifyApplicationReady(): Promise<void> {\n    return;\n  }\n\n  /**\n   * Reloads the application. If there is a pending update package installed using ON_NEXT_RESTART or ON_NEXT_RESUME modes, the update\n   * will be immediately visible to the user. Otherwise, calling this function will simply reload the current version of the application.\n   * @returns {Promise<void>}\n   */\n  @Cordova()\n  restartApplication(): Promise<void> {\n    return;\n  }\n\n  /**\n   * Convenience method for installing updates in one method call.\n   * This method is provided for simplicity, and its behavior can be replicated by using window.codePush.checkForUpdate(), RemotePackage's download() and LocalPackage's install() methods.\n   *\n   * The algorithm of this method is the following:\n   * - Checks for an update on the CodePush server.\n   * - If an update is available\n   *         - If the update is mandatory and the alertMessage is set in options, the user will be informed that the application will be updated to the latest version.\n   *           The update package will then be downloaded and applied.\n   *         - If the update is not mandatory and the confirmMessage is set in options, the user will be asked if they want to update to the latest version.\n   *           If they decline, the syncCallback will be invoked with SyncStatus.UPDATE_IGNORED.\n   *         - Otherwise, the update package will be downloaded and applied with no user interaction.\n   * - If no update is available on the server, or if a previously rolled back update is available and the ignoreFailedUpdates is set to true, the syncCallback will be invoked with the SyncStatus.UP_TO_DATE.\n   * - If an error occurs during checking for update, downloading or installing it, the syncCallback will be invoked with the SyncStatus.ERROR.\n   *\n   * @param {SyncOptions} [syncOptions] Optional SyncOptions parameter configuring the behavior of the sync operation.\n   * @param {SuccessCallback<DownloadProgress>} [downloadProgress] Optional callback invoked during the download process. It is called several times with one DownloadProgress parameter.\n   * @returns {Observable<SyncStatus>}\n   *\n   */\n  @Cordova({\n    observable: true,\n    successIndex: 0,\n    errorIndex: 3 // we don't need this, so we set it to a value higher than # of args\n  })\n  sync(\n    syncOptions?: SyncOptions,\n    downloadProgress?: SuccessCallback<DownloadProgress>\n  ): Observable<SyncStatus> {\n    return;\n  }\n}\n"]}